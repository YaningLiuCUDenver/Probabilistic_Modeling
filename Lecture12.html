<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>12&nbsp; Conditional Distribution of the Arrival Times – MATH 4792/5792 Probabilistic Modeling</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Lecture13.html" rel="next">
<link href="./Lecture11.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Lecture12.html"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Conditional Distribution of the Arrival Times</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">MATH 4792/5792 Probabilistic Modeling</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Stochastic Processes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction to Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Classification of States for Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Limiting Probabilities for Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Some Markov Chains Applications</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Time Reversible Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Hidden Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">The Exponential Distribution</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Further Properties of the Exponential Distribution</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">The Poisson Process</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Further Properties of Poisson Processes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture12.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Conditional Distribution of the Arrival Times</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Introduction to Continuous-Time Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Introduction to Queueing Theory</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Exponential Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture16.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Brownian Motion</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture17.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Variations on Brownian Motion and Pricing Stock Options</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture18.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Introduction to Monte Carlo Simulation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture19.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">General Techniques for Simulating Continuous Random Variables</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture20.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Special Techniques for Simulating Continuous Random Variables</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture21.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Simulating from Discrete Distributions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture22.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Simulating Stochastic Processes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture23.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Variance Reduction Techniques-Part I</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture24.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Variance Reduction Techniques-Part II</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture25.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Variance Reduction Techniques-Part III</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#conditional-distribution-of-the-arrival-times" id="toc-conditional-distribution-of-the-arrival-times" class="nav-link active" data-scroll-target="#conditional-distribution-of-the-arrival-times"><span class="header-section-number">12.1</span> Conditional Distribution of the Arrival Times</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Conditional Distribution of the Arrival Times</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="conditional-distribution-of-the-arrival-times" class="level2" data-number="12.1">
<h2 data-number="12.1" class="anchored" data-anchor-id="conditional-distribution-of-the-arrival-times"><span class="header-section-number">12.1</span> Conditional Distribution of the Arrival Times</h2>
<p>Suppose we are told that exactly one event of a Poisson process has taken place by time <span class="math inline">\(t\)</span>, and we are asked to determine the distribution of the time at which the event occurred. Now, since a Poisson process possesses stationary and independent increments it seems reasonable that each interval in <span class="math inline">\([0, t]\)</span> of equal length should have the same probability of containing the event. In other words, the time of the event should be uniformly distributed over <span class="math inline">\([0, t]\)</span>. This is easily checked since, for <span class="math inline">\(s \le t\)</span>, <span class="math display">\[
\begin{aligned}
P\{T_{1}&lt;s|N(t)=1\} &amp;= \frac{P\{T_{1}&lt;s,N(t)=1\}}{P\{N(t)=1\}} \\
                    &amp;=\frac{P\{1\mathrm{~event~in~}[0,s),0\mathrm{~events~in~}[s,t]\}}{P\{N(t)=1\}} \\
                    &amp;=\frac{P\{1\mathrm{~event~in~}[0,s)\}P\{0\mathrm{~events~in~}[s,t]\}}{P\{N(t)=1\}} \\
                    &amp;=\frac{\lambda se^{-\lambda s}e^{-\lambda(t-s)}}{\lambda te^{-\lambda t}} \\
                    &amp;=\frac{s}{t}
\end{aligned}
\]</span> This result may be generalized, but before doing so we need to introduce the concept of order statistics.</p>
<p>Let <span class="math inline">\(Y_1, Y_2, \ldots, Y_n\)</span> be <span class="math inline">\(n\)</span> random variables. We say that <span class="math inline">\(Y_{(1)}, Y_{(2)}, \ldots, Y_{(n)}\)</span> are the order statistics corresponding to <span class="math inline">\(Y_{1}, Y_{2}, \ldots, Y_{n}\)</span> if <span class="math inline">\(Y_{(k) }\)</span> is the <span class="math inline">\(k\)</span>th smallest value among <span class="math inline">\(Y_{1}, \ldots, Y_{n}, k= 1, 2, \ldots, n.\)</span> For instance if <span class="math inline">\(n=3\)</span> and <span class="math inline">\(Y_1=4\)</span>, <span class="math inline">\(Y_2=5\)</span>, <span class="math inline">\(Y_{3}=1\)</span> then <span class="math inline">\(Y_{(1)}=1,Y_{(2)}=4,Y_{(3)}=5.\)</span> If the <span class="math inline">\(Y_i,i=1,\ldots,n\)</span>,are independent identically distributed continuous random variables with probability density <span class="math inline">\(f\)</span>, then the joint density of the order statistics <span class="math inline">\(Y_{(1)},Y_{(2)},\ldots,\dot{Y}_{(n)}\)</span> is given by <span class="math display">\[
f(y_1,y_2,\dots,y_n)=n!\prod\limits_{i=1}^nf(y_i),\quad y_1&lt;y_2&lt;\dots&lt;y_n
\]</span> The preceding follows since</p>
<ol type="i">
<li>(<span class="math inline">\(Y_{(1)}\)</span>, <span class="math inline">\(Y_{(2)}\)</span>, <span class="math inline">\(\ldots\)</span>, <span class="math inline">\(Y_{(n)}\)</span>) will equal (<span class="math inline">\(y_{1}\)</span>, <span class="math inline">\(y_{2}\)</span>, <span class="math inline">\(\ldots\)</span>, <span class="math inline">\(y_{n}\)</span>) if (<span class="math inline">\(Y_{1}\)</span>, <span class="math inline">\(Y_{2}\)</span>, <span class="math inline">\(\ldots\)</span>, <span class="math inline">\(Y_{n}\)</span>) is equal to any of the <span class="math inline">\(n!\)</span> permutations of <span class="math inline">\((y_1,y_2,\ldots,y_n);\)</span></li>
</ol>
<p>and</p>
<ol start="2" type="i">
<li>the probability density that <span class="math inline">\((Y_1,Y_2,\ldots,Y_n)\)</span> is equal to <span class="math inline">\(y_{i_1},\ldots,y_{i_n}\)</span> is <span class="math inline">\(\prod_{j=1}^{n}f(y_{i_j})=\prod_{j=1}^{n}f(y_j)\)</span> when <span class="math inline">\(i_1,\ldots,i_n\)</span> is a permutation of <span class="math inline">\(1,2,\ldots,n\)</span></li>
</ol>
<p>If the <span class="math inline">\(Y_i,i=1,\ldots,n\)</span>, are uniformly distributed over <span class="math inline">\((0,t)\)</span>, then we obtain from the preceding that the joint density function of the order statistics <span class="math inline">\(Y_{(1)},Y_{(2)},\ldots,Y_{(n)}\)</span> is <span class="math display">\[
f(y_1,y_2,\ldots,y_n)=\frac{n!}{t^n},\quad0&lt;y_1&lt;y_2&lt;\cdots&lt;y_n&lt;t
\]</span> We are now ready for the following useful theorem.</p>
<div id="thm-thm1" class="theorem">
<p><span class="theorem-title"><strong>Theorem 12.1</strong></span> Given that <span class="math inline">\(N(t)=n\)</span>, the <span class="math inline">\(n\)</span> arrival times <span class="math inline">\(S_1,\ldots,S_n\)</span> have the same distribution as the order statistics corresponding to <span class="math inline">\(n\)</span> independent random variables uniformly distributed on the interval <span class="math inline">\((0,t).\)</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>To obtain the conditional density of <span class="math inline">\(S_1,\ldots,S_n\)</span> given that <span class="math inline">\(N(t)=n\)</span> note that for <span class="math inline">\(0&lt;S_1&lt;\cdots&lt;S_n&lt;t\)</span> the event that <span class="math inline">\(S_1=s_1,S_2=s_2,\ldots\)</span>, <span class="math inline">\(S_n=s_n,N(t)=n\)</span> is equivalent to the event that the first <span class="math inline">\(n+1\)</span> interarrival times satisfy <span class="math inline">\(T_1=s_1,T_2=s_2-s_1,\ldots,T_n=s_n-s_{n-1},T_{n+1}&gt;t-s_n.\)</span> Hence, using Proposition 1 in Lecture 7, we have that the conditional joint density of <span class="math inline">\(S_1,\ldots,S_n\)</span> given that <span class="math inline">\(N(t)=n\)</span> is as follows: <span class="math display">\[
\begin{aligned}
f(s_1,\dots,s_n|n) &amp;= \frac{f(s_1,\dots,s_n,n)}{P\{N(t)=n\}} \\
                   &amp;= \frac{\lambda e^{-\lambda s_1}\lambda e^{-\lambda (s_2-s_1)}\cdots\lambda e^{-\lambda(s_n-s_{n-1})}e^{-\lambda (t-s_n)}}{e^{-\lambda t}((\lambda t)^n/n!)} \\
                   &amp;= \frac{n!}{t^n}, \quad 0&lt; s_1&lt; \cdots &lt; s_n&lt; t
\end{aligned}
\]</span> which proves the result.</p>
</div>
<div id="rem-rem1" class="proof remark">
<p><span class="proof-title"><em>Remark 12.1</em>. </span>The preceding result is usually paraphrased as stating that, under the condition that <span class="math inline">\(n\)</span> events have occurred in <span class="math inline">\((0,t)\)</span>, the times <span class="math inline">\(S_1,\ldots,S_n\)</span> at which events occur, considered as unordered random variables, are distributed independently and uniformly in the interval <span class="math inline">\((0,t).\)</span></p>
</div>
<p><strong>Application of <a href="Lecture23.html#thm-thm1" class="quarto-xref">Theorem&nbsp;<span>23.1</span></a> (Sampling a Poisson Process)</strong> In Proposition 1 Lecture 8 we showed that if each event of a Poisson process is independently classified as a type I event with probability <span class="math inline">\(p\)</span> and as a type II event with probability <span class="math inline">\(1-p\)</span> then the counting processes of type I and type II events are independent Poisson processes with respective rates <span class="math inline">\(\lambda p\)</span> and <span class="math inline">\(\lambda(1-p).\)</span> Suppose now, however, that there are <span class="math inline">\(k\)</span> possible types of events and that the probability that an event is classificd as a type <span class="math inline">\(i\)</span> event, <span class="math inline">\(i=1,\ldots,k\)</span>, depends on the time the event occurs. Specifically, suppose that if an event occurs at time y then it will be classified as a type <span class="math inline">\(i\)</span> event, independently of anything that has previously occurred, with probability <span class="math inline">\(P_i(y),i=1,\ldots,k\)</span> where <span class="math inline">\(\sum_{i=1}^kP_i(y)=1.\)</span> Upon using <a href="Lecture23.html#thm-thm1" class="quarto-xref">Theorem&nbsp;<span>23.1</span></a> we can prove the following useful proposition.</p>
<div id="prp-prp1" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 12.1</strong></span> If <span class="math inline">\(N_i(t),i=1,\ldots,k\)</span>, represents the number of type <span class="math inline">\(i\)</span> events occurring by time <span class="math inline">\(t\)</span> then <span class="math inline">\(N_i(t),i=1,\ldots,k\)</span>, are independent Poisson random variables having means <span class="math display">\[E[N_i(t)]=\lambda\int_0^tP_i(s)\:ds\]</span> Before proving this proposition, let us first illustrate its use.</p>
</div>
<div id="exm-exa1" class="theorem example">
<p><span class="theorem-title"><strong>Example 12.1</strong></span> (An Infinite Server Queue) Suppose that customers arrive at a service station in accordance with a Poisson process with rate <span class="math inline">\(\lambda.\)</span> Upon arrival the customer is immediately served by one of an infinite number of possible servers, and the service times are assumed to be independent with a common distribution <span class="math inline">\(G.\)</span> What is the distribution of <span class="math inline">\(X(t)\)</span>, the number of customers that have completed service by time <span class="math inline">\(t?\)</span> What is the distribution of <span class="math inline">\(Y(t)\)</span>, the number of customers that are being served at time <span class="math inline">\(t?\)</span></p>
</div>
<p>To answer the preceding questions let us agree to call an entering customer a type I customer if he completes his service by time <span class="math inline">\(t\)</span> and a type II customer if he does not complete his service by time <span class="math inline">\(t.\)</span> Now, if the customer enters at time s, <span class="math inline">\(s\leqslant t\)</span>, then he will be a type I customer if his service time is less than <span class="math inline">\(t-s.\)</span> Since the service time distribution is <span class="math inline">\(G\)</span>, the probability of this will be <span class="math inline">\(G(t-s).\)</span> Similarly, a customer entering at time s, <span class="math inline">\(s\leqslant t\)</span>, will be a type II customer with probability <span class="math inline">\(\bar{G}(t-s)=1-G(t-s).\)</span> Hence, from <a href="Lecture24.html#prp-prp1" class="quarto-xref">Proposition&nbsp;<span>24.1</span></a> we obtain that the distribution of <span class="math inline">\(X(t)\)</span>, the number of customers that have completed service by time <span class="math inline">\(t\)</span>, is Poisson distributed with mean <span id="eq-eq5-17"><span class="math display">\[
E[X(t)]=\lambda\int_0^tG(t-s)\:ds=\lambda\int_0^tG(y)\:dy
\tag{12.1}\]</span></span> Similarly, the distribution of <span class="math inline">\(Y(t)\)</span>, the number of customers being served at time <span class="math inline">\(t\)</span> is Poisson with mean <span id="eq-eq5-18"><span class="math display">\[
E[Y(t)]=\lambda\int_0^t\bar{G}(t-s)\:ds=\lambda\int_0^t\bar{G}(y)\:dy
\tag{12.2}\]</span></span> Furthermore, <span class="math inline">\(X(t)\)</span> and <span class="math inline">\(Y(t)\)</span> are independent.</p>
<p>Suppose now that we are interested in computing the joint distribution of <span class="math inline">\(Y(t)\)</span> and <span class="math inline">\(Y(t+s)\)</span>—that is, the joint distribution of the number in the system at time <span class="math inline">\(t\)</span> and at time <span class="math inline">\(t+s.\)</span> To accomplish this, say that an arrival is</p>
<p>type l: if he arrives before time <span class="math inline">\(t\)</span> and completes service between <span class="math inline">\(t\)</span> and <span class="math inline">\(t+s\)</span>,</p>
<p>type 2: if he arrives before <span class="math inline">\(t\)</span> and completes service after <span class="math inline">\(t+s\)</span>,</p>
<p>type 3: if he arrives between <span class="math inline">\(t\)</span> and <span class="math inline">\(t+s\)</span> and completes service after <span class="math inline">\(t+s\)</span>,</p>
<p>type 4: otherwise.</p>
<p>Hence an arrival at time y will be type <span class="math inline">\(i\)</span> with probability <span class="math inline">\(P_i(y)\)</span> given by <span class="math display">\[
\begin{aligned}
&amp;P_{1}(y)=\begin{cases}G(t+s-y)-G(t-y),&amp;\quad\text{if }y&lt;t\\0,&amp;\quad\text{otherwise}\end{cases}\\
&amp;P_{2}(y)=\begin{cases}\tilde{G}(t+s-y),&amp;\quad\text{if }y&lt;t\\0,&amp;\quad\text{otherwise}\end{cases} \\
&amp;P_3(y)=\begin{cases}\bar G(t+s-y),&amp;\quad\text{if}\:t&lt;y&lt;t+s\\0,&amp;\quad\text{otherwise}\end{cases}\\
&amp;P_{4}(y)=1-P_{1}(y)-P_{2}(y)-P_{3}(y)
\end{aligned}
\]</span> Hence, if <span class="math inline">\(N_i=N_i(s+t), i=1,2,3\)</span>, denotes the number of type <span class="math inline">\(i\)</span> events that occur, then from <a href="Lecture24.html#prp-prp1" class="quarto-xref">Proposition&nbsp;<span>24.1</span></a>, <span class="math inline">\(N_i, i=1,2,3\)</span>, are independent Poisson random variables with respective means <span class="math display">\[
E[N_i]=\lambda\int_0^{t+s}P_i(y)\:dy,\quad i=1,2,3
\]</span> Because <span class="math display">\[
\begin{aligned}
Y(t)&amp;=N_1+N_2,\\
Y(t+s)&amp;=N_2+N_3
\end{aligned}
\]</span> it is now an easy matter to compute the joint distribution of <span class="math inline">\(Y(t)\)</span> and <span class="math inline">\(Y(t+s).\)</span> For instance, <span class="math display">\[
\begin{aligned}&amp;\mathrm{Cov}[Y(t),Y(t+s)]\\
&amp;=\mathrm{Cov}(N_{1}+N_{2},N_{2}+N_{3})\\
&amp;=\mathrm{Cov}(N_{2},N_{2})\quad\mathrm{by~independence~of~}N_{1},N_{2},N_{3}\\
&amp;=\mathrm{Var}(N_{2})\\
&amp;=\lambda\int_{0}^{t}\bar{G}(t+s-y)\:dy=\lambda\int_{0}^{t}\bar{G}(u+s)\:du
\end{aligned}
\]</span> where the last equality follows since the variance of a Poisson random variable equals its mean, and from the substitution <span class="math inline">\(u=t-y.\)</span> Also, the joint distribution of <span class="math inline">\(Y(t)\)</span> and <span class="math inline">\(Y(t+s)\)</span> is as follows: <span class="math display">\[
\begin{aligned}
P\{Y(t)&amp;=i,Y(t+s)=j\}=P\{N_{1}+N_{2}=i,N_{2}+N_{3}=j\}\\
&amp;=\sum_{l=0}^{\min(i,j)}P\{N_{2}=l,N_{1}=i-l,N_{3}=j-l\}\\
&amp;=\sum_{l=0}^{\min(i,j)}P\{N_{2}=l\}P\{N_{1}=i-l\}P\{N_{3}=j-l\}\quad\blacksquare
\end{aligned}
\]</span></p>
<div id="exm-exa2" class="theorem example">
<p><span class="theorem-title"><strong>Example 12.2</strong></span> (Tracking the Number of HIV Infections) There is a relatively long incubation period from the time when an individual becomes infected with the HIV virus, which causes AIDS, until the symptoms of the disease appear.</p>
<p>As a result, it is difficult for public health officials to be certain of the number of members of the population that are infected at any given time. We will now present a first approximation model for this phenomenon, which can be used to obtain a rough estimate of the number of infected individuals.</p>
<p>Let us suppose that individuals contract the HIV virus in accordance with a Poisson process whose rate <span class="math inline">\(\lambda\)</span> is unknown. Suppose that the time from when an individual becomes infected until symptoms of the disease appear is a random variable having a known distribution <span class="math inline">\(G\)</span>. Suppose also that the incubation times of different infected individuals are independent.</p>
<p>Let <span class="math inline">\(N_1(t)\)</span> denote the number of individuals who have shown symptoms of the disease by time <span class="math inline">\(t\)</span>. Also, let <span class="math inline">\(N_2(t)\)</span> denote the number who are HIV positive but have not yet shown any symptoms by time <span class="math inline">\(t\)</span>. Now, since an individual who contracts the virus at time <span class="math inline">\(s\)</span> will have symptoms by time <span class="math inline">\(t\)</span> with probability <span class="math inline">\(G(t − s)\)</span> and will not with probability <span class="math inline">\(\bar{G}(t - s)\)</span>, it follows from <a href="Lecture24.html#prp-prp1" class="quarto-xref">Proposition&nbsp;<span>24.1</span></a> that <span class="math inline">\(N_1(t)\)</span> and <span class="math inline">\(N_2(t)\)</span> are independent Poisson random variables with respective means <span class="math display">\[
E[N_1(t)] = \lambda \int_{0}^t G(t-s) ds = \lambda \int_{0}^t G(y)dy
\]</span> and <span class="math display">\[
E[N_2(t)] = \lambda \int_{0}^t \bar{G}(t-s) ds = \lambda \int_{0}^t \bar{G}(y)dy
\]</span> Now, if we knew <span class="math inline">\(\lambda\)</span>, then we could use it to estimate N2(t), the number of individuals infected but without any outward symptoms at time t , by its mean value E[N2(t)]. However, since λ is unknown, we must first estimate it. Now, we will presumably know the value of N1(t), and so we can use its known value as an estimate of its mean E[N1(t)]. That is, if the number of individuals who have exhibited symptoms by time t is n1, then we can estimate that <span class="math display">\[
n_1\approx E[N_1(t)] = \lambda \int_{0}^t G(y) dy
\]</span> Therefore, we can estimate <span class="math inline">\(\lambda\)</span> by the quantity <span class="math inline">\(\hat{\lambda}\)</span> given by <span class="math display">\[
\hat{\lambda} = n_1 / \int_{0}^t G(y) dy
\]</span> Using this estimate of <span class="math inline">\(\lambda\)</span>, we can estimate the number of infected but symptomless individuals at time <span class="math inline">\(t\)</span> by <span class="math display">\[
\begin{aligned}
\text{estimate of } N_2(t)  &amp;= \hat{\lambda} \int_{0}^t \hat{G}(y) dy \\
&amp;= \frac{n_1\int_{0}^t\hat{G}(y)dy}{\int_0^t G(y)dy}
\end{aligned}
\]</span> For example, suppose that <span class="math inline">\(G\)</span> is exponential with mean <span class="math inline">\(\mu.\)</span> Then <span class="math inline">\(\bar{G}(y)=e^-y/\mu\)</span> and a simple integration gives that <span class="math display">\[
\text{estimate of }N_2(t)=\frac{n_1\mu(1-e^{-t/\mu})}{t-\mu(1-e^{-t/\mu})}
\]</span> If we suppose that <span class="math inline">\(t=16\)</span> years, <span class="math inline">\(\mu=10\)</span> years, and <span class="math inline">\(n_1=220\)</span> thousand, then the estimate of the number of infected but symptomless individuals at time 16 is <span class="math display">\[
\text{estimate}=\frac{2,200(1-e^{-1.6})}{16-10(1-e^{-1.6})}=218.96
\]</span> That is, if we suppose that the foregoing model is approximately correct (and we should be aware that the assumption of a constant infection rate <span class="math inline">\(\lambda\)</span> that is unchanging over time is almost certainly a weak point of the model), then if the incubation period is exponential with mean 10 years and if the total number of individuals who have exhibited AIDS symptoms during the first 16 years of the epidemic is <span class="math inline">\(220\)</span> thousand, then we can expect that approximately <span class="math inline">\(219\)</span> thousand individuals are HIV positive though symptomless at time <span class="math inline">\(16\)</span>.</p>
</div>
<p><strong>Proof of Proposition 5.3</strong></p>
<p>Let us compute the joint probability <span class="math inline">\(P\{N_i(t)=n_i,i=1,\ldots,k\}.\)</span> To do so note first that in order for there to have been <span class="math inline">\(n_i\)</span> type <span class="math inline">\(i\)</span> events for <span class="math inline">\(i=1,\ldots,k\)</span> there must have been a total of <span class="math inline">\(\sum_i=1^kn_i\)</span> events. Hence, conditioning on <span class="math inline">\(N(t)\)</span> yields <span class="math display">\[
\begin{aligned}&amp;P\{N_{1}(t)=n_{1},\ldots,N_{k}(t)=n_{k}\} \\
&amp;=P\left\{N_{1}(t)=n_{1},\ldots,N_{k}(t)=n_{k}\:\Big|\:N(t)=\sum_{i=1}^{k}n_{i}\right\} \\
&amp;\times P\left\{N(t)=\sum_{i=1}^{k}n_{i}\right\}
\end{aligned}
\]</span> Now consider an arbitrary event that occurred in the interval <span class="math inline">\([0,t].\)</span> If it had occurred at time <span class="math inline">\(s\)</span>,then the probability that it would be a type <span class="math inline">\(i\)</span> event would be <span class="math inline">\(P_i(s).\)</span> Hence, since by <a href="Lecture23.html#thm-thm1" class="quarto-xref">Theorem&nbsp;<span>23.1</span></a> this event will have occurred at some time uniformly distributed on <span class="math inline">\((0,t)\)</span>, it follows that the probability that this event will be a type <span class="math inline">\(i\)</span> event is <span class="math display">\[
P_i = \frac{1}{t}\int_0^t P_i(s)ds
\]</span> independently of the other events. Hence, <span class="math display">\[
P\left\{N_i(t) = n_i, i = 1,\dots,k | N(t)=\sum_{i=1}^k n_i\right\}
\]</span> will just equal the multinomial probability of <span class="math inline">\(n_i\)</span> type i outcomes for <span class="math inline">\(i = 1, \dots, k\)</span> when each of <span class="math inline">\(\sum_{i=1}^kn_i\)</span> independent trials results in outcome <span class="math inline">\(i\)</span> with probability <span class="math inline">\(P_i, i = 1, \dots, k\)</span>. That is, <span class="math display">\[
P\left\{N_1(t) = n_1, \dots, N_k(t) = n_k | N(t)=\sum_{i=1}^k n_i\right\} = \frac{(\sum_{i=1}^k n_i)!}{n_1!\cdots n_k!}P_1^{n_1}\cdots P_{k}^{n_k}
\]</span> Consequently, <span class="math display">\[
\begin{aligned}
P\{N_1(t) = n_1, \dots, N_k(t) = n_k\} &amp;= \frac{(\sum_{i=1}^k n_i)!}{n_1!\cdots n_k!}P_1^{n_1}\cdots P_{k}^{n_k}e^{-\lambda t}\frac{(\lambda t)\sum_i n_i}{(\sum_i n_i)!} \\
&amp;= \prod_{i=1}^k e^{-\lambda t}P_i (\lambda t P_i)^{n_i} / n_i!
\end{aligned}
\]</span> and the proof is complete</p>
<p>We now present an additional example of the usefulness of <a href="Lecture23.html#thm-thm1" class="quarto-xref">Theorem&nbsp;<span>23.1</span></a>.</p>
<div id="exm-exa3" class="theorem example">
<p><span class="theorem-title"><strong>Example 12.3</strong></span> Insurance claims are made at times distributed according to a Poisson process with rate <span class="math inline">\(\lambda\)</span>; the successive claim amounts are independent random variables having distribution <span class="math inline">\(G\)</span> with mean <span class="math inline">\(\mu\)</span>, and are independent of the claim arrival times. Let <span class="math inline">\(S_i\)</span> and <span class="math inline">\(C_i\)</span> denote, respectively, the time and the amount of the <span class="math inline">\(i\)</span>th claim. The total discounted cost of all claims made up to time <span class="math inline">\(t\)</span> , call it <span class="math inline">\(D(t)\)</span>, is defined by <span class="math display">\[
D(t) = \sum_{i=1}^{N(t)} e^{-\alpha S_i}C_i
\]</span> where <span class="math inline">\(\alpha\)</span> is the discount rate and <span class="math inline">\(N(t)\)</span> is the number of claims made by time <span class="math inline">\(t\)</span>. To determine the expected value of <span class="math inline">\(D(t)\)</span>, we condition on <span class="math inline">\(N(t)\)</span> to obtain <span class="math display">\[
E[D(t)] = \sum_{n=0}^\infty E[D(t)|N(t)=n]e^{-\lambda t}\frac{(\lambda t)^n}{n!}
\]</span> Now, conditional on <span class="math inline">\(N(t) = n\)</span> the claim arrival times <span class="math inline">\(S_1, \dots, S_n\)</span> are distributed as the ordered values <span class="math inline">\(U_{(1)}, \dots, U_{(n)}\)</span> of <span class="math inline">\(n\)</span> independent uniform <span class="math inline">\((0, t)\)</span> random variables <span class="math inline">\(U_1, \dots, U_n\)</span>. Therefore, <span class="math display">\[
\begin{aligned}
E[D(t)|N(t)=n] &amp;= E\left[\sum_{i=1}^nC_ie^{-\alpha U_{(i)}}\right] \\
               &amp;= \sum_{i=1}^n E\left[C_ie^{-\alpha U_{(i)}}\right] \\
               &amp;= \sum_{i=1}^n E\left[C_i\right] E\left[e^{-\alpha U_{(i)}}\right]
\end{aligned}
\]</span> where the final equality used the independence of the claim amounts and their arrival times. Because <span class="math inline">\(E[C_i] = \mu\)</span>, continuing the preceding gives <span class="math display">\[
\begin{aligned}
E[D(t)|N(t)=n] &amp;= \mu  \sum_{i=1}^n E\left[e^{-\alpha U_{(i)}}\right]  \\
               &amp;= \mu E\left[\sum_{i=1}^n e^{-\alpha U_{(i)}}\right] \\
               &amp;= \mu E\left[\sum_{i=1}^n e^{-\alpha U_{i}}\right]
\end{aligned}
\]</span> The last equality follows because <span class="math inline">\(U_{(1)}, \dots, U_{(n)}\)</span> are the values <span class="math inline">\(U_1, \dots, U_n\)</span> in increasing order, and so <span class="math inline">\(\sum_{i=1}^n e^{-\alpha U_{(i)}} = \sum_{i=1}^n e^{-\alpha U_{i}}\)</span>. Continuing the string of equalities yields <span class="math display">\[
\begin{aligned}
E[D(t)|N(t)=n] &amp;= n\mu E\left[e^{-\alpha U}\right]  \\
               &amp;= n\frac{\mu}{t}\int_0^t e^{-\alpha x} dx \\
               &amp;= n\frac{\mu}{\alpha t}(1-e^{-\alpha t})
\end{aligned}
\]</span> Therefore, <span class="math display">\[
E[D(t)|N(t)] = N(t)\frac{\mu}{\alpha t}(1-e^{-\alpha t})
\]</span> Taking expectations yields the result <span class="math display">\[
E[D(t)] = \frac{\lambda\mu}{\alpha}(1-e^{-\alpha t})
\]</span></p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Lecture11.html" class="pagination-link" aria-label="Further Properties of Poisson Processes">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Further Properties of Poisson Processes</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Lecture13.html" class="pagination-link" aria-label="Introduction to Continuous-Time Markov Chains">
        <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Introduction to Continuous-Time Markov Chains</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>