<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>11&nbsp; Further Properties of Poisson Processes – MATH 4792/5792 Probabilistic Modeling</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Lecture12.html" rel="next">
<link href="./Lecture10.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Lecture11.html"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Further Properties of Poisson Processes</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">MATH 4792/5792 Probabilistic Modeling</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Stochastic Processes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introduction to Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Classification of States for Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Limiting Probabilities for Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Some Markov Chains Applications</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Time Reversible Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Hidden Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">The Exponential Distribution</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Further Properties of the Exponential Distribution</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">The Poisson Process</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture11.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Further Properties of Poisson Processes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Conditional Distribution of the Arrival Times</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Introduction to Continuous-Time Markov Chains</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Introduction to Queueing Theory</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Exponential Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture16.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Brownian Motion</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture17.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Variations on Brownian Motion and Pricing Stock Options</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture18.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Introduction to Monte Carlo Simulation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture19.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">General Techniques for Simulating Continuous Random Variables</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture20.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Special Techniques for Simulating Continuous Random Variables</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture21.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Simulating from Discrete Distributions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture22.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Simulating Stochastic Processes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture23.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Variance Reduction Techniques-Part I</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture24.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Variance Reduction Techniques-Part II</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Lecture25.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Variance Reduction Techniques-Part III</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#further-properties-of-poisson-processes" id="toc-further-properties-of-poisson-processes" class="nav-link active" data-scroll-target="#further-properties-of-poisson-processes"><span class="header-section-number">11.1</span> Further Properties of Poisson Processes</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Further Properties of Poisson Processes</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="further-properties-of-poisson-processes" class="level2" data-number="11.1">
<h2 data-number="11.1" class="anchored" data-anchor-id="further-properties-of-poisson-processes"><span class="header-section-number">11.1</span> Further Properties of Poisson Processes</h2>
<p>Consider a Poisson process <span class="math inline">\(\{N(t), t \ge 0\}\)</span> having rate <span class="math inline">\(\lambda\)</span>, and suppose that each time an event occurs it is classified as either a type I or a type II event. Suppose further that each event is classified as a type I event with probability <span class="math inline">\(p\)</span> or a type II event with probability <span class="math inline">\(1−p\)</span>, independently of all other events. For example, suppose that customers arrive at a store in accordance with a Poisson process having rate <span class="math inline">\(\lambda\)</span>; and suppose that each arrival is male with probability <span class="math inline">\(\frac{1}{2}\)</span> and female with probability <span class="math inline">\(\frac{1}{2}\)</span>. Then a type I event would correspond to a male arrival and a type II event to a female arrival.</p>
<p>Let <span class="math inline">\(N_1(t)\)</span> and <span class="math inline">\(N_2(t)\)</span> denote respectively the number of type I and type II events occurring in <span class="math inline">\([0, t]\)</span>. Note that <span class="math inline">\(N(t) = N_1(t) +N_2(t)\)</span>.</p>
<div id="prp-prp1" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 11.1</strong></span> <span class="math inline">\(\{N_1(t), t \ge 0\}\)</span> and <span class="math inline">\(\{N_2(t), t \ge 0\}\)</span> are both Poisson processes having respective rates <span class="math inline">\(\lambda p\)</span> and <span class="math inline">\(\lambda (1-p)\)</span>. Furthermore, the two processes are independent.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>It is easy to verify that <span class="math inline">\(\{N_1(t), t \ge 0\}\)</span> is a Poisson process with rate <span class="math inline">\(\lambda p\)</span> by verifying that it satisfies Definition 3 in Lecture 7.</p>
<ul>
<li><p><span class="math inline">\(N_1(0) = 0\)</span> follows from the fact that <span class="math inline">\(N(0) = 0\)</span>.</p></li>
<li><p>It is easy to see that <span class="math inline">\(\{N_1(t), t \ge 0\}\)</span> inherits the stationary and independent increment properties of the process <span class="math inline">\(\{N(t), t \ge 0\}\)</span>. This is true because the distribution of the number of type I events in an interval can be obtained by conditioning on the number of events in that interval, and the distribution of this latter quantity depends only on the length of the interval and is independent of what has occurred in any nonoverlapping interval.</p></li>
<li><p><span class="math display">\[
  \begin{aligned}
      P\{N_1(h) =1\} &amp;= P\{N_1(h) = 1 | N(h) = 1\} P\{N(h) =1\} \\
                     &amp;+ P\{N_1(h) = 1 | N(h)\ge 2\} P\{N(h) \ge 2\} \\
                     &amp;= p(\lambda h + o(h) + o(h)) \\
                     &amp;= \lambda ph + o(h)
  \end{aligned}
\]</span></p></li>
<li><p><span class="math inline">\(P\{N_1(h) \ge 2\} \le P\{N(h) \ge 2\} = o(h)\)</span></p></li>
</ul>
<p>Thus we see that <span class="math inline">\(\{N_1(t), t \ge 0\}\)</span> is a Poisson process with rate <span class="math inline">\(\lambda p\)</span> and, by a similar argument, that <span class="math inline">\(\{N_2(t), t \ge 0\}\)</span> is a Poisson process with rate <span class="math inline">\(\lambda (1−p)\)</span>. Because the probability of a type I event in the interval from <span class="math inline">\(t\)</span> to <span class="math inline">\(t + h\)</span> is independent of all that occurs in intervals that do not overlap <span class="math inline">\((t, t + h)\)</span>, it is independent of knowledge of when type II events occur, showing that the two Poisson processes are independent.</p>
</div>
<div id="exm-exa1" class="theorem example">
<p><span class="theorem-title"><strong>Example 11.1</strong></span> If immigrants to area <span class="math inline">\(A\)</span> arrive at a Poisson rate of ten per week, and if each immigrant is of English descent with probability <span class="math inline">\(\frac{1}{12}\)</span>, then what is the probability that no people of English descent will emigrate to area A during the month of February?</p>
</div>
<div id="sol-sol1" class="proof solution">
<p><span class="proof-title"><em>Solution 11.1</em>. </span>By the previous proposition it follows that the number of Englishmen emigrating to area A during the month of February is Poisson distributed with mean <span class="math inline">\(4(10)(\frac{1}{12})=\frac{10}{3}\)</span>. Hence the desired probability is <span class="math inline">\(e^{-10/3}\)</span></p>
</div>
<div id="aca2492d" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> poisson</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_immigrating_process(lam, n, p):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Simulate a immigrating Poisson process with Poisson rate lam for n periods. The chance of an immigrant being English is p</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    input:</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">    lam: float, the Poisson rate</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">    n: int, the number of periods to simulate.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">    p: float, probability for an immigrant to be English</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">    output:</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">    E: int, the number of English immigrants during n periods.</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    E <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):  <span class="co"># simulate n periods</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        n_of_immigrants <span class="op">=</span>  poisson.rvs(mu<span class="op">=</span>lam)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        E <span class="op">+=</span> np.<span class="bu">sum</span>(np.random.random(n_of_immigrants) <span class="op">&lt;</span> p )</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> E</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f070948c" class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>lam <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span>  <span class="co"># 4 periods in February</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">12</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>sample_size <span class="op">=</span> <span class="dv">100000</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> np.zeros(sample_size, dtype <span class="op">=</span> <span class="st">'int'</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(sample_size):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    E[i] <span class="op">=</span> generate_immigrating_process(lam, n, p)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>prob <span class="op">=</span> np.<span class="bu">sum</span>(E <span class="op">==</span> <span class="dv">0</span>) <span class="op">/</span> sample_size</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'By simulation, no people of English descent will emigrate to area A during the month of February is: '</span>,</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>      prob, <span class="st">' </span><span class="ch">\n</span><span class="st"> and the theoretical probability is: '</span>, np.exp(<span class="op">-</span><span class="dv">10</span><span class="op">/</span><span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="exm-exa2" class="theorem example">
<p><span class="theorem-title"><strong>Example 11.2</strong></span> Suppose nonnegative offers to buy an item that you want to sell arrive according to a Poisson process with rate <span class="math inline">\(\lambda\)</span>. Assume that each offer is the value of a continuous random variable having density function <span class="math inline">\(f(x)\)</span>. Once the offer is presented to you, you must either accept it or reject it and wait for the next offer. We suppose that you incur costs at a rate c per unit time until the item is sold, and that your objective is to maximize your expected total return, where the total return is equal to the amount received minus the total cost incurred. Suppose you employ the policy of accepting the first offer that is greater than some specified value y. (Such a type of policy, which we call a y-policy, can be shown to be optimal.) What is the best value of y?</p>
</div>
<div id="sol-sol2" class="proof solution">
<p><span class="proof-title"><em>Solution 11.3</em>. </span>Let us compute the expected total return when you use the y-policy, and then choose the value of <span class="math inline">\(y\)</span> that maximizes this quantity. Let <span class="math inline">\(X\)</span> denote the value of a random offer, and let <span class="math inline">\(\bar{F}(x) = P\{X&gt; x\} = \int_x^\infty f(u)du\)</span> be its tail distribution function. Because each offer will be greater than <span class="math inline">\(y\)</span> with probability <span class="math inline">\(\bar{F}(y)\)</span>, it follows that such offers occur according to a Poisson process with rate <span class="math inline">\(λ \bar{F}(y)\)</span>. Hence, the time until an offer is accepted is an exponential random variable with rate <span class="math inline">\(λ \bar{F}(y)\)</span>. Letting <span class="math inline">\(R(y)\)</span> denote the total return from the policy that accepts the first offer that is greater than <span class="math inline">\(y\)</span>, we have <span class="math display">\[
\begin{aligned}
E[R(y)]&amp;=E[\text{accepted offer}]-cE[\text{time to accept}] \\
       &amp;=E[X|X&gt;y]-\frac{c}{\lambda\bar{F}(y)} \\
       &amp;=\int_{0}^{\infty}xf_{X|X&gt;y}(x)\:dx - \frac{c}{\lambda\bar{F}(y)} \\
       &amp;=\int_{y}^{\infty}x\frac{f(x)}{\bar{F}(y)}\:dx - \frac{c}{\lambda\bar{F}(y)} \\
       &amp;=\frac{\int_{y}^{\infty}xf(x)\:dx - c/\lambda}{\bar{F}(y)}
\end{aligned}
\]</span> Differentiation yields that <span class="math display">\[
\frac{d}{dy}E[R(y)]=0\Leftrightarrow-\bar{F}(y)yf(y)+\left(\int_{y}^{\infty}xf(x)\:dx-\frac{c}{\lambda}\right)f(y)=0
\]</span> Therefore, the optimal value of <span class="math inline">\(y\)</span> satisfies <span class="math display">\[
y\bar{F}(y)=\int_{y}^{\infty}xf(x)\:dx-\frac{c}{\lambda}
\]</span> or <span class="math display">\[
y\int_y^\infty f(x)\:dx=\int_y^\infty xf(x)\:dx-\frac{c}{\lambda}
\]</span> or <span id="eq-eq5-14"><span class="math display">\[
\int_{y}^{\infty}(x-y)f(x)\:dx=\frac{c}{\lambda}
\tag{11.1}\]</span></span> We now argue that the left-hand side of the preceding is a nonincreasing function of <span class="math inline">\(y\)</span>. To do so, note that, with <span class="math inline">\(a^+\)</span> defined to equal <span class="math inline">\(a\)</span> if <span class="math inline">\(a &gt; 0\)</span> or to equal <span class="math inline">\(0\)</span> otherwise, we have <span class="math display">\[
\int_y^\infty(x-y)f(x)\:dx = E[(X-y)^+]
\]</span> Because <span class="math inline">\((X-y)^+\)</span> is a nonincreasing function of <span class="math inline">\(y\)</span>, so is its expectation, thus showing that the left hand side of <a href="#eq-eq5-14" class="quarto-xref">Equation&nbsp;<span>11.1</span></a> is a nonincreasing function of <span class="math inline">\(y\)</span>. Consequently, if <span class="math inline">\(E[X]&lt;c/\lambda—\)</span> in which case there is no solution of <a href="#eq-eq5-14" class="quarto-xref">Equation&nbsp;<span>11.1</span></a>—then it is optimal to accept any offer; otherwise, the optimal value y is the unique solution of <a href="#eq-eq5-14" class="quarto-xref">Equation&nbsp;<span>11.1</span></a>.</p>
</div>
<p>It follows from <a href="Lecture24.html#prp-prp1" class="quarto-xref">Proposition&nbsp;<span>24.1</span></a> that if each of a Poisson number of individuals is independently classified into one of two possible groups with respective probabilities <span class="math inline">\(p\)</span> and <span class="math inline">\(1 - p\)</span>, then the number of individuals in each of the two groups will be independent Poisson random variables. Because this result easily generalizes to the case where the classification is into any one of <span class="math inline">\(r\)</span> possible groups, we have the following application to a model of employees moving about in an organization.</p>
<div id="exm-exa2" class="theorem example">
<p><span class="theorem-title"><strong>Example 11.3</strong></span> Consider a system in which individuals at any time are classified as being in one of <span class="math inline">\(r\)</span> possible states, and assume that an individual changes states in accordance with a Markov chain having transition probabilities <span class="math inline">\(P_{ij}, i, j = 1, \dots, r\)</span>. That is, if an individual is in state <span class="math inline">\(i\)</span> during a time period then, independently of its previous states, it will be in state <span class="math inline">\(j\)</span> during the next time period with probability <span class="math inline">\(P_{ij}\)</span>. The individuals are assumed to move through the system independently of each other. Suppose that the numbers of people initially in states <span class="math inline">\(1, 2, \dots, r\)</span> are independent Poisson random variables with respective means <span class="math inline">\(\lambda_1, \lambda_2, \dots, \lambda_r\)</span>. We are interested in determining the joint distribution of the numbers of individuals in states <span class="math inline">\(1, 2, \dots, r\)</span> at some time <span class="math inline">\(n\)</span>.</p>
</div>
<div id="sol-sol2" class="proof solution">
<p><span class="proof-title"><em>Solution 11.3</em>. </span>For fixed <span class="math inline">\(i\)</span>, let <span class="math inline">\(N_j (i), j = 1, \dots, r\)</span> denote the number of those individuals, initially in state <span class="math inline">\(i\)</span>, that are in state <span class="math inline">\(j\)</span> at time <span class="math inline">\(n\)</span>. Now each of the (Poisson distributed) number of people initially in state <span class="math inline">\(i\)</span> will, independently of each other, be in state <span class="math inline">\(j\)</span> at time <span class="math inline">\(n\)</span> with probability $P^n_{ij} , where <span class="math inline">\(P^n_{ij}\)</span> is the <span class="math inline">\(n\)</span>-stage transition probability for the Markov chain having transition probabilities <span class="math inline">\(P_{ij}\)</span> . Hence, the <span class="math inline">\(N_j(i), j = 1, \dots, r\)</span> will be independent Poisson random variables with respective means <span class="math inline">\(λ_iP^n_{ij}, j = 1, \dots, r\)</span>. Because the sum of independent Poisson random variables is itself a Poisson random variable, it follows that the number of individuals in state <span class="math inline">\(j\)</span> at time n—namely <span class="math inline">\(\sum^r_{i=1} N_j(i)\)</span>—will be independent Poisson random variables with respective means <span class="math inline">\(\sum_i \lambda_iP^n_{ij}\)</span>, for <span class="math inline">\(j=1, \dots, r\)</span>.</p>
</div>
<div id="exp-exa3">
<p>(The Coupon Collecting Problem) There are m different types of coupons. Each time a person collects a coupon it is, independently of ones previously obtained, a type <span class="math inline">\(j\)</span> coupon with probability <span class="math inline">\(p_j , \sum^m_{j=1} p_j = 1\)</span>. Let <span class="math inline">\(N\)</span> denote the number of coupons one needs to collect in order to have a complete collection of at least one of each type. Find <span class="math inline">\(E[N]\)</span>.</p>
</div>
<div id="sol-sol3" class="proof solution">
<p><span class="proof-title"><em>Solution 11.4</em>. </span>If we let <span class="math inline">\(N_j\)</span> denote the number one must collect to obtain a type <span class="math inline">\(j\)</span> coupon, then we can express <span class="math inline">\(N\)</span> as <span class="math display">\[
N = \max_{1\le j\le m}N_j
\]</span> However, even though each <span class="math inline">\(N_j\)</span> is geometric with parameter <span class="math inline">\(p_j\)</span>, the foregoing representation of <span class="math inline">\(N\)</span> is not that useful, because the random variables <span class="math inline">\(N_j\)</span> are not independent.</p>
<p>We can, however, transform the problem into one of determining the expected value of the maximum of independent random variables. To do so, suppose that coupons are collected at times chosen according to a Poisson process with rate <span class="math inline">\(\lambda = 1\)</span>. Say that an event of this Poisson process is of type <span class="math inline">\(j\)</span>, <span class="math inline">\(1 \le j \le m\)</span>, if the coupon obtained at that time is a type <span class="math inline">\(j\)</span> coupon. If we now let <span class="math inline">\(N_j(t)\)</span> denote the number of type <span class="math inline">\(j\)</span> coupons collected by time <span class="math inline">\(t\)</span> , then it follows from <a href="Lecture24.html#prp-prp1" class="quarto-xref">Proposition&nbsp;<span>24.1</span></a> that <span class="math inline">\(\{N_j(t ), t \ge 0\}\)</span>, <span class="math inline">\(j = 1, \dots, m\)</span> are independent Poisson processes with respective rates <span class="math inline">\(\lambda p_j = p_j\)</span>. Let <span class="math inline">\(X_j\)</span> denote the time of the first event of the <span class="math inline">\(j\)</span>th process, and let <span class="math display">\[
X=\max_{1\leqslant j\leqslant m}X_j
\]</span> denote the time at which a complete collection is amassed. Since the <span class="math inline">\(X_j\)</span> are independent exponential random variables with respective rates <span class="math inline">\(p_j\)</span>, it follows that <span class="math display">\[
\begin{aligned}
P\{X&lt;t\}&amp;=P\{\max X_{j}&lt;t\}\\&amp;=P\{X_{j}&lt;t,\mathrm{~for~}j=1,\ldots,m\}\\&amp;=\prod_{j=1}^{m}(1-e^{-p_{j}t})
\end{aligned}
\]</span> Therefore, <span id="eq-eq5-15"><span class="math display">\[
\begin{aligned}
E[X] &amp;=\int_{0}^{\infty}P\{X&gt;t\}\:dt \\
     &amp;=\int_{0}^{\infty}\left\{1-\prod_{j=1}^{m}(1-e^{-p_{j}t})\right\}dt
\end{aligned}
\tag{11.2}\]</span></span> It remains to relate <span class="math inline">\(E[X]\)</span>, the expected time until one has a complete set, to <span class="math inline">\(E[N]\)</span>, the expected number of coupons it takes. This can be done by letting <span class="math inline">\(T_i\)</span> denote the <span class="math inline">\(i\)</span>th interarrival time of the Poisson process that counts the number of coupons obtained. Then it is easy to see that <span class="math display">\[
X=\sum_{i=1}^NT_i
\]</span> Since the <span class="math inline">\(T_i\)</span> are independent exponentials with rate <span class="math inline">\(1\)</span>, and <span class="math inline">\(N\)</span> is independent of the <span class="math inline">\(T_i\)</span>, we see that <span class="math display">\[
E[X|N]=NE[T_i]=N
\]</span> Therefore, <span class="math display">\[
E[X]=E[N]
\]</span> and so <span class="math inline">\(E[N]\)</span> is as given in <a href="#eq-eq5-15" class="quarto-xref">Equation&nbsp;<span>11.2</span></a>.</p>
<p>Let us now compute the expected number of types that appear only once in the complete collection. Letting <span class="math inline">\(I_i\)</span> equal l if there is only a single type <span class="math inline">\(i\)</span> coupon in the final set, and letting it equal 0 otherwise, we thus want <span class="math display">\[
\begin{aligned}
E\left[\sum_{i=1}^{m}I_{i}\right] &amp;=\sum_{i=1}^mE[I_i] \\
                                  &amp;=\sum_{i=1}^mP\{I_i=1\}
\end{aligned}
\]</span></p>
<p>Now there will be a single type <span class="math inline">\(i\)</span> coupon in the final set if a coupon of each type has appeared before the second coupon of type <span class="math inline">\(i\)</span> is obtained. Thus, letting <span class="math inline">\(S_i\)</span> denote the time at which the second type <span class="math inline">\(i\)</span> coupon is obtained, we have <span class="math display">\[
P\{I_i=1\}=P\{X_j&lt;S_i, \text{ for all } j\ne i\}
\]</span> Using that <span class="math inline">\(S_i\)</span> has a gamma distribution with parameters (2, pi), this yields <span class="math display">\[
\begin{aligned}
P\{I_{i}=1\} &amp;=\int_{0}^{\infty}P\{X_{j}&lt;S_{i}\mathrm{~for~all~}j\neq i|S_{i}=x\}p_{i}e^{-p_{i}x}\:p_{i}x\:dx \\
             &amp;=\int_{0}^{\infty}P\{X_{j}&lt;x,\mathrm{~for~all~}j\neq i\}p_{i}^{2}x\:e^{-p_{i}x}\:dx \\
             &amp;=\int_{0}^{\infty}\prod_{j\neq i}(1-e^{-p_{j}x})\:p_{i}^{2}xe^{-p_{i}x}\:dx
\end{aligned}
\]</span> Therefore, we have the result <span class="math display">\[
\begin{aligned}
E\left[\sum_{i=1}^{m}I_{i}\right] &amp;=\int_{0}^{\infty}\sum_{i=1}^{m}\prod_{j\neq i}(1-e^{-p_{j}x})p_{i}^{2}xe^{-p_{i}x}\:dx\\
&amp;=\int_{0}^{\infty}x\prod_{j=1}^{m}(1-e^{-p_{j}x})\sum_{i=1}^{m}p_{i}^{2}\frac{e^{-p_{i}x}}{1-e^{-p_{i}x}}\:dx\quad\blacksquare
\end{aligned}
\]</span></p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Lecture10.html" class="pagination-link" aria-label="The Poisson Process">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">The Poisson Process</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Lecture12.html" class="pagination-link" aria-label="Conditional Distribution of the Arrival Times">
        <span class="nav-page-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Conditional Distribution of the Arrival Times</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>